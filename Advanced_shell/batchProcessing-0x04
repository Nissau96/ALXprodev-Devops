# --- Configuration ---
POKEMON_LIST=("Bulbasaur" "Ivysaur" "Venusaur" "Charmander" "Charmeleon" "Pikachu" "Snorlax" "Mewtwo")
OUTPUT_DIR="pokemon_data_parallel"

# --- Function to Fetch Data ---
fetch_one_pokemon() {
    local pokemon_name=$1
    local pokemon_lower=$(echo "$pokemon_name" | tr '[:upper:]' '[:lower:]')
    
    local API_URL="https://pokeapi.co/api/v2/pokemon/${pokemon_lower}"
    local OUTPUT_FILE="${OUTPUT_DIR}/${pokemon_lower}.json"

    echo "Starting download for ${pokemon_lower}..."
    
    local HTTP_STATUS=$(curl -s -L -o "$OUTPUT_FILE" -w "%{http_code}" "$API_URL")

    if [[ "$HTTP_STATUS" -ge 200 && "$HTTP_STATUS" -lt 300 ]]; then
        echo "✅ Success: ${pokemon_lower}"
    else
        echo "❌ Failed:  ${pokemon_lower} (Status: ${HTTP_STATUS})"
        rm -f "$OUTPUT_FILE"
    fi
}

# --- Main Script Logic ---
mkdir -p "$OUTPUT_DIR"

# Array to store the PIDs of the background jobs.
pids=()

# Set a trap. This will ensure that if the script is interrupted, it will kill all background jobs.
trap 'kill ${pids[*]} 2>/dev/null' EXIT

echo "Dispatching all Pokémon downloads in parallel..."

for pokemon in "${POKEMON_LIST[@]}"; do
    fetch_one_pokemon "$pokemon" &
    # Store the PID of the process we just sent to the background.
    pids+=($!)
done

echo "All jobs dispatched. Waiting for completion..."
# The 'wait' command pauses until all background jobs complete.
wait

echo "All parallel downloads have completed."
# The trap command will automatically run now as the script exits.